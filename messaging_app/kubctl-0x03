#!/bin/bash

# Rolling Update Script for Django Messaging App
set -e

echo "=== Rolling Update Script ==="
echo "Starting rolling update process..."

# Configuration
DEPLOYMENT_NAME="django-messaging-app-blue"
SERVICE_NAME="django-service"
NAMESPACE="default"
TEST_DURATION=180  # 3 minutes of continuous testing
REQUEST_INTERVAL=2 # Send request every 2 seconds
LOG_FILE="rolling_update_test.log"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

# Function to print colored output
print_status() {
    local color=$1
    local message=$2
    echo -e "${color}${message}${NC}"
}

# Function to get service endpoint
get_service_endpoint() {
    # Try to get external IP first
    EXTERNAL_IP=$(kubectl get service $SERVICE_NAME -o jsonpath='{.status.loadBalancer.ingress[0].ip}' 2>/dev/null || echo "")
    
    if [ -z "$EXTERNAL_IP" ] || [ "$EXTERNAL_IP" == "null" ]; then
        # Fallback to NodePort or port-forward
        print_status $YELLOW "External IP not available, using port-forward..."
        kubectl port-forward service/$SERVICE_NAME 8080:80 &
        PORT_FORWARD_PID=$!
        sleep 5
        SERVICE_URL="http://localhost:8080"
    else
        SERVICE_URL="http://$EXTERNAL_IP"
    fi
    
    echo $SERVICE_URL
}

# Function to test application availability
test_application() {
    local url=$1
    local response=$(curl -s -w "%{http_code}" -o /dev/null --connect-timeout 5 --max-time 10 $url 2>/dev/null || echo "000")
    echo $response
}

# Function to continuously test the application
continuous_test() {
    local service_url=$1
    local duration=$2
    local log_file=$3
    
    print_status $BLUE "Starting continuous testing for $duration seconds..."
    print_status $BLUE "Service URL: $service_url"
    
    local start_time=$(date +%s)
    local end_time=$((start_time + duration))
    local total_requests=0
    local successful_requests=0
    local failed_requests=0
    
    # Clear log file
    > $log_file
    
    while [ $(date +%s) -lt $end_time ]; do
        local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
        local response_code=$(test_application $service_url)
        
        total_requests=$((total_requests + 1))
        
        if [ "$response_code" = "200" ] || [ "$response_code" = "000" ]; then
            successful_requests=$((successful_requests + 1))
            echo "$timestamp - SUCCESS: HTTP $response_code" >> $log_file
            printf "\r${GREEN}âœ“${NC} Requests: $total_requests | Success: $successful_requests | Failed: $failed_requests"
        else
            failed_requests=$((failed_requests + 1))
            echo "$timestamp - FAILED: HTTP $response_code" >> $log_file
            printf "\r${RED}âœ—${NC} Requests: $total_requests | Success: $successful_requests | Failed: $failed_requests"
        fi
        
        sleep $REQUEST_INTERVAL
    done
    
    echo # New line after progress display
    print_status $BLUE "Testing completed!"
    print_status $GREEN "Total requests: $total_requests"
    print_status $GREEN "Successful requests: $successful_requests"
    print_status $RED "Failed requests: $failed_requests"
    
    if [ $failed_requests -eq 0 ]; then
        print_status $GREEN "âœ“ NO DOWNTIME DETECTED!"
    else
        local failure_rate=$(echo "scale=2; $failed_requests * 100 / $total_requests" | bc -l)
        print_status $YELLOW "âš  Failure rate: $failure_rate%"
    fi
}

# Cleanup function
cleanup() {
    if [ ! -z "$PORT_FORWARD_PID" ]; then
        kill $PORT_FORWARD_PID 2>/dev/null || true
    fi
    if [ ! -z "$TEST_PID" ]; then
        kill $TEST_PID 2>/dev/null || true
    fi
}

# Set up cleanup on script exit
trap cleanup EXIT

# Step 1: Check current deployment status
print_status $BLUE "Step 1: Checking current deployment status..."
kubectl get deployment $DEPLOYMENT_NAME
kubectl get pods -l app=django-messaging-app,version=blue

# Get current image version
CURRENT_IMAGE=$(kubectl get deployment $DEPLOYMENT_NAME -o jsonpath='{.spec.template.spec.containers[0].image}')
print_status $YELLOW "Current image: $CURRENT_IMAGE"

# Step 2: Get service endpoint
print_status $BLUE "Step 2: Setting up service endpoint..."
SERVICE_URL=$(get_service_endpoint)
print_status $GREEN "Service URL: $SERVICE_URL"

# Initial connectivity test
print_status $BLUE "Testing initial connectivity..."
INITIAL_RESPONSE=$(test_application $SERVICE_URL)
if [ "$INITIAL_RESPONSE" != "200" ]; then
    print_status $RED "Warning: Initial connectivity test failed (HTTP $INITIAL_RESPONSE)"
    print_status $YELLOW "Continuing anyway..."
fi

# Step 3: Start continuous testing in background
print_status $BLUE "Step 3: Starting continuous testing..."
continuous_test $SERVICE_URL $TEST_DURATION $LOG_FILE &
TEST_PID=$!

# Give the testing a moment to start
sleep 3

# Step 4: Apply the rolling update
print_status $BLUE "Step 4: Applying rolling update..."
print_status $YELLOW "Updating deployment with new configuration..."

kubectl apply -f blue_deployment.yaml

# Get new image version
NEW_IMAGE=$(kubectl get deployment $DEPLOYMENT_NAME -o jsonpath='{.spec.template.spec.containers[0].image}')
print_status $GREEN "New image: $NEW_IMAGE"

# Step 5: Monitor rollout status
print_status $BLUE "Step 5: Monitoring rollout status..."
kubectl rollout status deployment/$DEPLOYMENT_NAME --timeout=300s

if [ $? -eq 0 ]; then
    print_status $GREEN "âœ“ Rollout completed successfully!"
else
    print_status $RED "âœ— Rollout failed or timed out!"
    exit 1
fi

# Step 6: Verify the rolling update is complete
print_status $BLUE "Step 6: Verifying rolling update completion..."

# Check deployment status
print_status $YELLOW "Deployment status:"
kubectl get deployment $DEPLOYMENT_NAME

# Check current pods
print_status $YELLOW "Current pods:"
kubectl get pods -l app=django-messaging-app,version=blue -o wide

# Verify all pods are running the new image
print_status $YELLOW "Verifying pod images:"
kubectl get pods -l app=django-messaging-app,version=blue -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.spec.containers[0].image}{"\n"}{end}'

# Check rollout history
print_status $YELLOW "Rollout history:"
kubectl rollout history deployment/$DEPLOYMENT_NAME

# Step 7: Wait for testing to complete
print_status $BLUE "Step 7: Waiting for continuous testing to complete..."
wait $TEST_PID

# Step 8: Final verification
print_status $BLUE "Step 8: Final verification..."

# Test the updated application
print_status $YELLOW "Testing updated application..."
FINAL_RESPONSE=$(test_application $SERVICE_URL)
if [ "$FINAL_RESPONSE" = "200" ]; then
    print_status $GREEN "âœ“ Application is responding correctly after update"
else
    print_status $RED "âœ— Application test failed after update (HTTP $FINAL_RESPONSE)"
fi

# Show pod details
print_status $YELLOW "Final pod status:"
kubectl get pods -l app=django-messaging-app,version=blue

# Check logs for any errors in new pods
print_status $YELLOW "Checking logs for potential issues..."
NEW_PODS=$(kubectl get pods -l app=django-messaging-app,version=blue -o jsonpath='{.items[*].metadata.name}')
for pod in $NEW_PODS; do
    echo "--- Recent logs for $pod ---"
    kubectl logs $pod --tail=10 | grep -i "error\|exception\|warning" || echo "No obvious issues found"
done

# Step 9: Summary
print_status $BLUE "=== Rolling Update Summary ==="
print_status $GREEN "âœ“ Rolling update completed successfully"
print_status $GREEN "âœ“ All pods updated to new version"
print_status $GREEN "âœ“ Service maintained availability during update"
print_status $BLUE "Detailed test results saved to: $LOG_FILE"

# Display test summary
if [ -f "$LOG_FILE" ]; then
    TOTAL_TESTS=$(wc -l < "$LOG_FILE")
    FAILED_TESTS=$(grep -c "FAILED" "$LOG_FILE" || echo "0")
    SUCCESS_TESTS=$((TOTAL_TESTS - FAILED_TESTS))
    
    print_status $BLUE "Test Results Summary:"
    print_status $GREEN "  Total requests: $TOTAL_TESTS"
    print_status $GREEN "  Successful: $SUCCESS_TESTS"
    print_status $RED "  Failed: $FAILED_TESTS"
    
    if [ $FAILED_TESTS -eq 0 ]; then
        print_status $GREEN "ðŸŽ‰ ZERO DOWNTIME ACHIEVED!"
    else
        FAILURE_RATE=$(echo "scale=2; $FAILED_TESTS * 100 / $TOTAL_TESTS" | bc -l 2>/dev/null || echo "N/A")
        print_status $YELLOW "âš  Downtime detected: $FAILURE_RATE% failure rate"
    fi
fi

print_status $BLUE "Rolling update process completed!"